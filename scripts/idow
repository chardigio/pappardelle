#!/bin/bash

# idow - Interactively Do on Worktree
#
# A command-line tool that sets up a development workspace.
#
# Usage: idow [--resume] [--open] [--profile <name>] <input>
#   Input can be:
#     - Issue key:   idow STA-123 | idow 123
#     - Linear URL:  idow https://linear.app/stardust-labs/issue/STA-123
#     - Description: idow "add dark mode to settings"
#
# This command:
#   1. Parses input (issue key, URL, or description)
#   2. Creates/fetches issue as needed
#   3. Selects project profile from .pappardelle.yml
#   4. Creates a git worktree at ~/.worktrees/<project>/<issue-key>
#   5. Creates PR/MR (if new)
#   6. Opens iTerm with Claude
#   7. Opens profile-configured apps, links, and commands
#   8. Organizes windows in AeroSpace workspace

set -e

SCRIPT_NAME="idow"

# Get the directory where this script lives (resolving symlinks)
SCRIPT_SOURCE="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_SOURCE" ]]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_SOURCE")" && pwd)"
    SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
    [[ "$SCRIPT_SOURCE" != /* ]] && SCRIPT_SOURCE="$SCRIPT_DIR/$SCRIPT_SOURCE"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_SOURCE")" && pwd)"

# Logging setup
LOG_DIR="$HOME/Library/Logs/stardust-workspace"
mkdir -p "$LOG_DIR"
LOG_FILE="$LOG_DIR/idow.log"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

error() {
    echo "Error: $*" >&2
    log "Error: $*"
    exit 1
}

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

TOTAL_STEPS=13
print_step() {
    echo -e "${BLUE}[$(printf '%2d' $1)/$TOTAL_STEPS]${NC} $2"
    log "Step $1: $2"
}

print_success() {
    echo -e "${GREEN}  ✓${NC} $1"
    log "  Success: $1"
}

print_warning() {
    echo -e "${YELLOW}  ⚠${NC} $1"
    log "  Warning: $1"
}

# Handle help flag
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    echo "Usage: idow [--resume] [--profile <name>] <input>"
    echo ""
    echo "Input can be:"
    echo "  Issue key:   idow STA-123 | idow 123"
    echo "  Linear URL:  idow https://linear.app/stardust-labs/issue/STA-123"
    echo "  Description: idow \"add dark mode to settings\""
    echo ""
    echo "Options:"
    echo "  --resume          Open workspace without prompting Claude (for continuing work)"
    echo "  --open            Also open apps, links, iTerm, and run commands (skipped by default)"
    echo "  --profile <name>  Force a specific profile from .pappardelle.yml"
    exit 0
fi

# Get repo root and config path
# Prefer PAPPARDELLE_PROJECT_ROOT (set by pappardelle TUI) over git resolution.
# Fallback uses cwd (not $SCRIPT_DIR) so direct invocations from a project dir work.
if [[ -n "${PAPPARDELLE_PROJECT_ROOT:-}" ]]; then
    REPO_ROOT="$PAPPARDELLE_PROJECT_ROOT"
else
    REPO_ROOT=$(git rev-parse --show-toplevel)
fi
CONFIG_PATH="$REPO_ROOT/.pappardelle.yml"

# Check for config file
if [[ ! -f "$CONFIG_PATH" ]]; then
    echo -e "${YELLOW}Error: No .pappardelle.yml found at repository root.${NC}" >&2
    echo "" >&2
    echo "Pappardelle requires a configuration file to operate." >&2
    echo "Please create .pappardelle.yml at: $REPO_ROOT/.pappardelle.yml" >&2
    echo "" >&2
    echo "See _dev/scripts/pappardelle/pappardelle-config.md for the configuration schema." >&2
    exit 1
fi

# Check for yq (YAML processor)
if ! command -v yq &> /dev/null; then
    error "yq is required but not installed. Install with: brew install yq"
fi

# Read initialization command from config (e.g., "/idow" or empty)
INIT_CMD=$(yq -r '.claude.initialization_command // ""' "$CONFIG_PATH")

# Source provider-agnostic helpers
# shellcheck source=provider-helpers.sh
source "$SCRIPT_DIR/provider-helpers.sh"

# Detect configured providers
TRACKER_PROVIDER=$(get_issue_tracker_provider "$CONFIG_PATH")
VCS_PROVIDER=$(get_vcs_host_provider "$CONFIG_PATH")

# Helper function to get profile value
get_profile_value() {
    local profile="$1"
    local path="$2"
    yq -r ".profiles.$profile.$path // \"\"" "$CONFIG_PATH"
}

# Helper function to list all profiles
list_profiles() {
    yq -r '.profiles | keys | .[]' "$CONFIG_PATH"
}

# Helper function to get profile display name
get_profile_display_name() {
    local profile="$1"
    yq -r ".profiles.$profile.display_name // \"$profile\"" "$CONFIG_PATH"
}

# Helper function to check if a profile has iOS config
profile_has_ios() {
    local profile="$1"
    local app_dir
    app_dir=$(get_profile_value "$profile" "ios.app_dir")
    [[ -n "$app_dir" ]]
}

# Function to match profiles based on keywords
match_profiles() {
    local input="$1"
    local input_lower
    input_lower=$(echo "$input" | tr '[:upper:]' '[:lower:]')

    local matched_profiles=()

    for profile in $(list_profiles); do
        local keywords
        keywords=$(yq -r ".profiles.$profile.keywords[]" "$CONFIG_PATH" 2>/dev/null)

        for keyword in $keywords; do
            local keyword_lower
            keyword_lower=$(echo "$keyword" | tr '[:upper:]' '[:lower:]')

            if [[ "$input_lower" == *"$keyword_lower"* ]]; then
                # Check if profile is already in matched list
                local already_matched=false
                for mp in "${matched_profiles[@]}"; do
                    if [[ "$mp" == "$profile" ]]; then
                        already_matched=true
                        break
                    fi
                done

                if [[ "$already_matched" == false ]]; then
                    matched_profiles+=("$profile")
                fi
                break
            fi
        done
    done

    echo "${matched_profiles[@]}"
}

# Function to prompt user to select a profile
select_profile_interactive() {
    local preselected="$1"

    # Output prompts to stderr so stdout only contains the result
    echo "" >&2
    echo -e "${CYAN}Select a project profile:${NC}" >&2
    echo "" >&2

    local profiles=()
    local i=1

    for profile in $(list_profiles); do
        local display_name
        display_name=$(get_profile_display_name "$profile")

        if [[ "$profile" == "$preselected" ]]; then
            echo -e "  ${GREEN}[$i] $display_name (auto-detected)${NC}" >&2
        else
            echo "  [$i] $display_name" >&2
        fi

        profiles+=("$profile")
        ((i++))
    done

    echo "" >&2

    # Default to preselected if available
    local default_num=""
    if [[ -n "$preselected" ]]; then
        for j in "${!profiles[@]}"; do
            if [[ "${profiles[$j]}" == "$preselected" ]]; then
                default_num=$((j + 1))
                break
            fi
        done
    fi

    local prompt="Enter number"
    if [[ -n "$default_num" ]]; then
        prompt="$prompt [$default_num]"
    fi
    prompt="$prompt: "

    # If stdin is not a tty, use the default/preselected without prompting
    if [[ ! -t 0 ]]; then
        if [[ -n "$default_num" ]]; then
            echo "${profiles[$((default_num - 1))]}"
            return
        else
            # No default, use first profile
            echo "${profiles[0]}"
            return
        fi
    fi

    read -r -p "$prompt" selection

    # Use default if empty
    if [[ -z "$selection" && -n "$default_num" ]]; then
        selection="$default_num"
    fi

    # Validate selection
    if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ "$selection" -lt 1 ]] || [[ "$selection" -gt "${#profiles[@]}" ]]; then
        error "Invalid selection: $selection"
    fi

    echo "${profiles[$((selection - 1))]}"
}

# Check for --resume flag
RESUME_MODE=false
if [[ "$1" == "--resume" ]]; then
    RESUME_MODE=true
    shift
fi

# Check for --open flag (opt-in to opening apps/links/iTerm/commands)
# By default, idow only does setup (worktree, PR, etc.) without opening anything.
# Pass --open to also open iTerm, apps, links, simulator, and commands.
OPEN_WORKSPACE=false
if [[ "$1" == "--open" ]]; then
    OPEN_WORKSPACE=true
    shift
fi

# Check for --profile flag
FORCED_PROFILE=""
if [[ "$1" == "--profile" ]]; then
    FORCED_PROFILE="$2"
    shift 2

    # Validate the profile exists
    if ! list_profiles | grep -q "^${FORCED_PROFILE}$"; then
        echo -e "${YELLOW}Error: Profile \"$FORCED_PROFILE\" not found.${NC}" >&2
        echo "" >&2
        echo "Available profiles:" >&2
        for profile in $(list_profiles); do
            local display_name
            display_name=$(get_profile_display_name "$profile")
            echo "  - $profile: $display_name" >&2
        done
        exit 1
    fi
fi

# Collect input from all arguments
INPUT="$*"

if [[ -z "$INPUT" ]]; then
    echo "Usage: idow [--profile <name>] <input>"
    echo ""
    echo "Input can be:"
    echo "  Issue key:   idow STA-123 | idow 123"
    echo "  Linear URL:  idow https://linear.app/stardust-labs/issue/STA-123"
    echo "  Description: idow \"add dark mode to settings\""
    exit 1
fi

log "=== $SCRIPT_NAME started ==="
log "Input: $INPUT"

echo ""
echo "Starting workspace setup..."
echo ""

# Read team prefix from config (used for bare-number issue input and issue creation)
TEAM_PREFIX=$(yq -r '.team_prefix // "STA"' "$CONFIG_PATH" | tr '[:lower:]' '[:upper:]')

# Determine input type and extract issue key if applicable
ISSUE_KEY=""
DESCRIPTION=""
IS_NEW_ISSUE=false

if [[ "$INPUT" =~ ^https://linear\.app/.*/issue/([A-Z]+-[0-9]+) ]]; then
    # Linear URL
    ISSUE_KEY="${BASH_REMATCH[1]}"
    log "Detected Linear URL, issue key: $ISSUE_KEY"
elif [[ "$INPUT" =~ ^[A-Z]+-[0-9]+$ ]]; then
    # Full issue key (e.g., STA-123)
    ISSUE_KEY="$INPUT"
    log "Detected full issue key: $ISSUE_KEY"
elif [[ "$INPUT" =~ ^[0-9]+$ ]]; then
    # Just a number (e.g., 123) - use configured team prefix
    ISSUE_KEY="${TEAM_PREFIX}-$INPUT"
    log "Detected number, assuming issue key: $ISSUE_KEY"
else
    # It's a description - we'll create a new issue
    DESCRIPTION="$INPUT"
    IS_NEW_ISSUE=true
    log "Detected description, will create new issue"
fi

# Step 1: Select profile from .pappardelle.yml
print_step 1 "Selecting project profile..."

SELECTED_PROFILE=""

if [[ -n "$FORCED_PROFILE" ]]; then
    # Profile was specified via --profile flag
    SELECTED_PROFILE="$FORCED_PROFILE"
    print_success "Using profile: $(get_profile_display_name "$SELECTED_PROFILE") (forced)"
elif [[ "$IS_NEW_ISSUE" == true ]]; then
    # Try to match profile based on description keywords
    MATCHED_PROFILES=$(match_profiles "$DESCRIPTION")
    MATCHED_COUNT=$(echo "$MATCHED_PROFILES" | wc -w | tr -d ' ')

    if [[ "$MATCHED_COUNT" -eq 1 ]]; then
        # Single match - auto-select but allow override
        SELECTED_PROFILE=$(select_profile_interactive "$MATCHED_PROFILES")
    elif [[ "$MATCHED_COUNT" -gt 1 ]]; then
        # Multiple matches - prompt user, suggest first match
        FIRST_MATCH=$(echo "$MATCHED_PROFILES" | awk '{print $1}')
        SELECTED_PROFILE=$(select_profile_interactive "$FIRST_MATCH")
    else
        # No matches - use default profile, prompt user
        DEFAULT_PROFILE=$(yq -r '.default_profile' "$CONFIG_PATH")
        SELECTED_PROFILE=$(select_profile_interactive "$DEFAULT_PROFILE")
    fi
    print_success "Selected profile: $(get_profile_display_name "$SELECTED_PROFILE")"
else
    # Existing issue - use default profile, Claude can adjust later
    DEFAULT_PROFILE=$(yq -r '.default_profile' "$CONFIG_PATH")
    SELECTED_PROFILE="$DEFAULT_PROFILE"
    print_success "Using default profile: $(get_profile_display_name "$SELECTED_PROFILE")"
fi

# Extract profile values
IOS_APP_DIR=$(get_profile_value "$SELECTED_PROFILE" "ios.app_dir")
BUNDLE_ID=$(get_profile_value "$SELECTED_PROFILE" "ios.bundle_id")
SCHEME=$(get_profile_value "$SELECTED_PROFILE" "ios.scheme")
HAS_IOS=$(profile_has_ios "$SELECTED_PROFILE" && echo "true" || echo "false")

# Use profile name as project key
PROJECT_KEY="$SELECTED_PROFILE"

log "Profile: $SELECTED_PROFILE, iOS: $HAS_IOS, App Dir: $IOS_APP_DIR, Bundle: $BUNDLE_ID"

# Step 2: Get or create issue
print_step 2 "Setting up issue ($TRACKER_PROVIDER)..."

if [[ "$IS_NEW_ISSUE" == true ]]; then
    # Derive title
    print_step 3 "Generating issue title..."
    TITLE=$("$SCRIPT_DIR/derive-title.sh" "$DESCRIPTION") || error "Failed to derive title"
    print_success "Title: $TITLE"

    # Create issue via provider
    print_step 4 "Creating issue..."
    ISSUE_JSON=$(create_issue --title "$TITLE" --prompt "$DESCRIPTION" --config "$CONFIG_PATH" --team "$TEAM_PREFIX") || error "Failed to create issue"
    ISSUE_KEY=$(echo "$ISSUE_JSON" | jq -r '.issue_key')
    ISSUE_URL=$(echo "$ISSUE_JSON" | jq -r '.issue_url')
    print_success "Created issue: $ISSUE_KEY (project will be assigned by Claude)"

    # Write issue metadata for hook tracking (plan → description vs comment)
    ISSUE_META_DIR="$HOME/.pappardelle/issue-meta"
    mkdir -p "$ISSUE_META_DIR"
    echo "{\"created_by_pappardelle\": true, \"created_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}" > "$ISSUE_META_DIR/$ISSUE_KEY.json"
else
    # Fetch existing issue via provider
    print_step 3 "Fetching issue ($TRACKER_PROVIDER)..."
    ISSUE_JSON=$(fetch_issue_json "$ISSUE_KEY" "$CONFIG_PATH") || error "Failed to fetch issue $ISSUE_KEY"
    TITLE=$(extract_issue_title "$ISSUE_JSON" "$CONFIG_PATH")
    DESCRIPTION=$(extract_issue_description "$ISSUE_JSON" "$CONFIG_PATH")
    ISSUE_URL=$(build_issue_url "$ISSUE_KEY" "$CONFIG_PATH")

    if [[ -z "$TITLE" ]]; then
        error "Issue $ISSUE_KEY not found"
    fi
    print_success "Issue: $TITLE"

    # Get project info from issue if available
    print_step 4 "Checking project..."
    LINEAR_PROJECT=$(echo "$ISSUE_JSON" | jq -r '.project.name // empty')
    if [[ -n "$LINEAR_PROJECT" ]]; then
        print_success "Project: $LINEAR_PROJECT"
    else
        print_success "No project assigned (will use defaults)"
    fi
fi

# Step 5: Create or find worktree
print_step 5 "Setting up git worktree..."
REPO_NAME=$(basename "$REPO_ROOT")
WORKTREE_PATH="$HOME/.worktrees/$REPO_NAME/$ISSUE_KEY"

if [[ -d "$WORKTREE_PATH" ]]; then
    print_success "Worktree exists: $WORKTREE_PATH"
else
    WORKTREE_JSON=$("$SCRIPT_DIR/create-worktree.sh" --issue-key "$ISSUE_KEY" --project-key "$PROJECT_KEY") || error "Failed to create worktree"
    WORKTREE_PATH=$(echo "$WORKTREE_JSON" | jq -r '.worktree_path')
    print_success "Created worktree: $WORKTREE_PATH"
fi

# Step 6: Create or find PR/MR
print_step 6 "Setting up PR/MR ($VCS_PROVIDER)..."
cd "$WORKTREE_PATH"
PR_URL=$(check_existing_pr "$CONFIG_PATH")
if [[ -n "$PR_URL" ]]; then
    print_success "Found PR/MR: $PR_URL"
else
    # Create placeholder PR/MR for any issue without one (new or existing)
    PR_JSON=$(create_pr \
        --issue-key "$ISSUE_KEY" \
        --title "$TITLE" \
        --worktree "$WORKTREE_PATH" \
        --config "$CONFIG_PATH" \
        --prompt "$DESCRIPTION") || {
        print_warning "Failed to create PR/MR"
        PR_URL=""
        PR_JSON="{}"
    }
    PR_URL=$(echo "$PR_JSON" | jq -r '.pr_url // empty')
    if [[ -n "$PR_URL" ]]; then
        print_success "Created PR/MR: $PR_URL"
    fi
fi

# Step 7: Generate Xcode project (if iOS profile)
XCODEPROJ_PATH=""
if [[ "$HAS_IOS" == "true" && -n "$IOS_APP_DIR" ]]; then
    print_step 7 "Generating Xcode project..."
    XCODE_JSON=$("$SCRIPT_DIR/generate-xcode-project.sh" --worktree "$WORKTREE_PATH" --issue-key "$ISSUE_KEY" --ios-app-dir "$IOS_APP_DIR") || {
        print_warning "Failed to generate Xcode project"
        XCODE_JSON="{}"
    }
    XCODEPROJ_PATH=$(echo "$XCODE_JSON" | jq -r '.xcodeproj_path // empty')
    if [[ -n "$XCODEPROJ_PATH" ]]; then
        print_success "Xcode project: $(basename "$XCODEPROJ_PATH")"
    fi
else
    print_step 7 "Skipping Xcode project (no iOS config)..."
    print_success "Profile has no iOS configuration"
fi

# Template expansion helpers for profile-driven steps
expand_var() {
    local template="$1"
    local result="$template"
    result="${result//\$\{WORKTREE_PATH\}/$WORKTREE_PATH}"
    result="${result//\$\{ISSUE_KEY\}/$ISSUE_KEY}"
    result="${result//\$\{ISSUE_URL\}/$ISSUE_URL}"
    result="${result//\$\{REPO_ROOT\}/$REPO_ROOT}"
    result="${result//\$\{REPO_NAME\}/$REPO_NAME}"
    result="${result//\$\{PR_URL\}/$PR_URL}"
    result="${result//\$\{MR_URL\}/$PR_URL}"
    result="${result//\$\{XCODEPROJ_PATH\}/$XCODEPROJ_PATH}"
    result="${result//\$\{IOS_APP_DIR\}/$IOS_APP_DIR}"
    result="${result//\$\{BUNDLE_ID\}/$BUNDLE_ID}"
    result="${result//\$\{SCHEME\}/$SCHEME}"
    result="${result//\$\{SCRIPT_DIR\}/$SCRIPT_DIR}"
    result="${result//\$\{TITLE\}/$TITLE}"
    result="${result//\$\{DESCRIPTION\}/$DESCRIPTION}"
    echo "$result"
}

# Check if a template variable is set (for if_set gating)
var_is_set() {
    local var_name="$1"
    [[ -z "$var_name" ]] && return 0  # no condition = always include
    case "$var_name" in
        WORKTREE_PATH) [[ -n "$WORKTREE_PATH" ]] ;;
        PR_URL|MR_URL) [[ -n "$PR_URL" ]] ;;
        XCODEPROJ_PATH) [[ -n "$XCODEPROJ_PATH" && -d "$XCODEPROJ_PATH" ]] ;;
        ISSUE_URL) [[ -n "$ISSUE_URL" ]] ;;
        IOS_APP_DIR) [[ -n "$IOS_APP_DIR" ]] ;;
        BUNDLE_ID) [[ -n "$BUNDLE_ID" ]] ;;
        SCHEME) [[ -n "$SCHEME" ]] ;;
        TITLE) [[ -n "$TITLE" ]] ;;
        DESCRIPTION) [[ -n "$DESCRIPTION" ]] ;;
        *) [[ -n "${!var_name:-}" ]] ;;  # fall back to env var indirect ref
    esac
}

# Step 8: Ensure Claude and lazygit tmux sessions exist (always, regardless of --open)
print_step 8 "Starting Claude tmux session..."
CLAUDE_SESSION_ARGS=(--issue-key "$ISSUE_KEY" --repo-name "$REPO_NAME" --worktree "$WORKTREE_PATH")
if [[ -n "$INIT_CMD" && "$RESUME_MODE" != true ]]; then
    CLAUDE_SESSION_ARGS+=(--init-cmd "$INIT_CMD")
fi
CLAUDE_SESSION_NAME="claude-${REPO_NAME}-${ISSUE_KEY}"
"$SCRIPT_DIR/start-claude-session.sh" "${CLAUDE_SESSION_ARGS[@]}" || print_warning "Failed to start Claude tmux session"
if tmux has-session -t "$CLAUDE_SESSION_NAME" 2>/dev/null; then
    print_success "Claude session: $CLAUDE_SESSION_NAME"
else
    print_warning "Claude session not created (is tmux running?)"
fi

# Steps 9-12: Open apps, links, iTerm, simulator, commands
# Skipped by default. Pass --open to run these steps.
# In pappardelle, user presses 'o' on a space to open.
if [[ "$OPEN_WORKSPACE" != true ]]; then
    print_step 9 "Skipping open steps (pass --open to open apps)"
    print_success "Setup complete"
else

# Step 9: Open iTerm with Claude and lazygit
print_step 9 "Opening iTerm with Claude..."
# In resume mode, start Claude without any prompt; otherwise use configured init command
if [[ "$RESUME_MODE" == true ]]; then
    "$SCRIPT_DIR/open-iterm-claude.sh" --worktree "$WORKTREE_PATH" --issue-key "$ISSUE_KEY" --repo-name "$REPO_NAME" --prompt "" || {
        print_warning "Failed to open iTerm"
    }
    print_success "iTerm opened with Claude (resume mode)"
elif [[ -n "$INIT_CMD" ]]; then
    CLAUDE_PROMPT="$INIT_CMD $ISSUE_KEY"
    "$SCRIPT_DIR/open-iterm-claude.sh" --worktree "$WORKTREE_PATH" --issue-key "$ISSUE_KEY" --repo-name "$REPO_NAME" --prompt "$CLAUDE_PROMPT" || {
        print_warning "Failed to open iTerm"
    }
    print_success "iTerm opened with Claude session ($INIT_CMD)"
else
    "$SCRIPT_DIR/open-iterm-claude.sh" --worktree "$WORKTREE_PATH" --issue-key "$ISSUE_KEY" --repo-name "$REPO_NAME" --prompt "$ISSUE_KEY" || {
        print_warning "Failed to open iTerm"
    }
    print_success "iTerm opened with Claude (issue key only)"
fi

# Step 10: Open apps from profile
print_step 10 "Opening profile apps..."

APP_COUNT=$(yq -r ".profiles.$SELECTED_PROFILE.apps | length // 0" "$CONFIG_PATH" 2>/dev/null)
if [[ "$APP_COUNT" -gt 0 ]]; then
    for (( i=0; i<APP_COUNT; i++ )); do
        APP_NAME=$(yq -r ".profiles.$SELECTED_PROFILE.apps[$i].name // \"\"" "$CONFIG_PATH")
        APP_PATH_TMPL=$(yq -r ".profiles.$SELECTED_PROFILE.apps[$i].path // \"\"" "$CONFIG_PATH")
        APP_CMD_TMPL=$(yq -r ".profiles.$SELECTED_PROFILE.apps[$i].command // \"\"" "$CONFIG_PATH")
        APP_IF_SET=$(yq -r ".profiles.$SELECTED_PROFILE.apps[$i].if_set // \"\"" "$CONFIG_PATH")

        # Check if_set condition
        if ! var_is_set "$APP_IF_SET"; then
            log "  Skipping app '$APP_NAME' (if_set '$APP_IF_SET' not set)"
            continue
        fi

        APP_PATH=$(expand_var "$APP_PATH_TMPL")
        APP_CMD=$(expand_var "$APP_CMD_TMPL")

        if [[ -n "$APP_CMD" ]]; then
            eval "$APP_CMD" || print_warning "Failed: $APP_NAME"
            print_success "$APP_NAME opened (command)"
        elif [[ "$APP_NAME" == "Cursor" ]]; then
            cursor "$APP_PATH" || print_warning "Failed to open Cursor"
            print_success "Cursor opened"
        elif [[ "$APP_NAME" == "Xcode" ]]; then
            if [[ -n "$APP_PATH" && -d "$APP_PATH" ]]; then
                open "$APP_PATH"
                print_success "Xcode opened"
            else
                log "  Skipping Xcode (path not found: $APP_PATH)"
            fi
        else
            if [[ -n "$APP_PATH" ]]; then
                open -a "$APP_NAME" "$APP_PATH" || print_warning "Failed to open $APP_NAME"
            else
                open -a "$APP_NAME" || print_warning "Failed to open $APP_NAME"
            fi
            print_success "$APP_NAME opened"
        fi

        # Window positioning from layout config
        LAYOUT_POS=$(yq -r ".profiles.$SELECTED_PROFILE.layout.positions.\"$APP_NAME\" // \"\"" "$CONFIG_PATH" 2>/dev/null)
        if [[ -n "$LAYOUT_POS" ]]; then
            "$SCRIPT_DIR/position-window.sh" \
                --app "$APP_NAME" \
                --title "$ISSUE_KEY" \
                --workspace "$ISSUE_KEY" \
                --position "$LAYOUT_POS" &
        fi
    done
else
    print_success "No apps configured in profile"
fi

# Step 11: Open links from profile
print_step 11 "Opening profile links..."

LINK_COUNT=$(yq -r ".profiles.$SELECTED_PROFILE.links | length // 0" "$CONFIG_PATH" 2>/dev/null)
if [[ "$LINK_COUNT" -gt 0 ]]; then
    LINK_URLS=()
    for (( i=0; i<LINK_COUNT; i++ )); do
        LINK_URL_TMPL=$(yq -r ".profiles.$SELECTED_PROFILE.links[$i].url // \"\"" "$CONFIG_PATH")
        LINK_TITLE=$(yq -r ".profiles.$SELECTED_PROFILE.links[$i].title // \"\"" "$CONFIG_PATH")
        LINK_IF_SET=$(yq -r ".profiles.$SELECTED_PROFILE.links[$i].if_set // \"\"" "$CONFIG_PATH")

        if ! var_is_set "$LINK_IF_SET"; then
            log "  Skipping link '$LINK_TITLE' (if_set '$LINK_IF_SET' not set)"
            continue
        fi

        LINK_URL=$(expand_var "$LINK_URL_TMPL")
        if [[ -n "$LINK_URL" ]]; then
            LINK_URLS+=("$LINK_URL")
            log "  Link: $LINK_TITLE -> $LINK_URL"
        fi
    done

    if [[ ${#LINK_URLS[@]} -gt 0 ]]; then
        open "${LINK_URLS[@]}" || print_warning "Failed to open some links"
        print_success "Opened ${#LINK_URLS[@]} link(s) in browser"
    else
        print_success "No links to open (all filtered by if_set)"
    fi
else
    print_success "No links configured in profile"
fi

# Step 12: Setup QA simulator (if iOS profile)
SIM_PID=""
if [[ "$HAS_IOS" == "true" && -n "$IOS_APP_DIR" && -n "$BUNDLE_ID" ]]; then
    print_step 12 "Setting up QA simulator..."
    "$SCRIPT_DIR/setup-qa-simulator.sh" --worktree "$WORKTREE_PATH" --issue-key "$ISSUE_KEY" --ios-app-dir "$IOS_APP_DIR" --bundle-id "$BUNDLE_ID" &
    SIM_PID=$!
    print_success "Simulator setup started (building in background)"
else
    print_step 12 "Skipping QA simulator (no iOS config)..."
    print_success "Profile has no iOS configuration"
fi

# Step 13: Run profile commands and hooks
print_step 13 "Running commands..."

# Profile-level commands
CMD_COUNT=$(yq -r ".profiles.$SELECTED_PROFILE.commands | length // 0" "$CONFIG_PATH" 2>/dev/null)
if [[ "$CMD_COUNT" -gt 0 ]]; then
    for (( i=0; i<CMD_COUNT; i++ )); do
        CMD_NAME=$(yq -r ".profiles.$SELECTED_PROFILE.commands[$i].name // \"command $i\"" "$CONFIG_PATH")
        CMD_RUN_TMPL=$(yq -r ".profiles.$SELECTED_PROFILE.commands[$i].run // \"\"" "$CONFIG_PATH")
        CMD_CONTINUE=$(yq -r ".profiles.$SELECTED_PROFILE.commands[$i].continue_on_error // false" "$CONFIG_PATH")
        CMD_BG=$(yq -r ".profiles.$SELECTED_PROFILE.commands[$i].background // false" "$CONFIG_PATH")

        CMD_RUN=$(expand_var "$CMD_RUN_TMPL")

        if [[ -n "$CMD_RUN" ]]; then
            log "  Command: $CMD_NAME -> $CMD_RUN"
            if [[ "$CMD_BG" == "true" ]]; then
                eval "$CMD_RUN" &
                print_success "$CMD_NAME (background)"
            elif [[ "$CMD_CONTINUE" == "true" ]]; then
                eval "$CMD_RUN" || print_warning "Command '$CMD_NAME' failed (continuing)"
                print_success "$CMD_NAME"
            else
                eval "$CMD_RUN" || { log "Command '$CMD_NAME' failed — aborting workspace setup"; exit 1; }
                print_success "$CMD_NAME"
            fi
        fi
    done
fi

# Global post_workspace_create hooks
HOOK_COUNT=$(yq -r '.hooks.post_workspace_create | length // 0' "$CONFIG_PATH" 2>/dev/null)
if [[ "$HOOK_COUNT" -gt 0 ]]; then
    log "Running $HOOK_COUNT post_workspace_create hook(s)..."
    for (( i=0; i<HOOK_COUNT; i++ )); do
        HOOK_NAME=$(yq -r ".hooks.post_workspace_create[$i].name // \"hook $i\"" "$CONFIG_PATH")
        HOOK_RUN=$(yq -r ".hooks.post_workspace_create[$i].run // \"\"" "$CONFIG_PATH")
        HOOK_CONTINUE=$(yq -r ".hooks.post_workspace_create[$i].continue_on_error // false" "$CONFIG_PATH")
        HOOK_BG=$(yq -r ".hooks.post_workspace_create[$i].background // false" "$CONFIG_PATH")

        HOOK_RUN=$(expand_var "$HOOK_RUN")

        if [[ -n "$HOOK_RUN" ]]; then
            log "  Hook: $HOOK_NAME -> $HOOK_RUN"
            if [[ "$HOOK_BG" == "true" ]]; then
                eval "$HOOK_RUN" &
            elif [[ "$HOOK_CONTINUE" == "true" ]]; then
                eval "$HOOK_RUN" || print_warning "Hook '$HOOK_NAME' failed (continuing)"
            else
                eval "$HOOK_RUN" || { log "Hook '$HOOK_NAME' failed — aborting workspace setup"; exit 1; }
            fi
        fi
    done
fi

if [[ "$CMD_COUNT" -eq 0 && "$HOOK_COUNT" -eq 0 ]]; then
    print_success "No commands or hooks configured"
fi

# Wait for simulator if started
if [[ -n "$SIM_PID" ]]; then
    echo ""
    echo "Waiting for simulator..."
    if wait "$SIM_PID" 2>/dev/null; then
        print_success "Simulator ready"
    else
        print_warning "Simulator setup may have failed"
    fi
fi

# Switch to the workspace
aerospace workspace "$ISSUE_KEY" 2>/dev/null || true

fi # end of OPEN_WORKSPACE check

# Final summary
echo ""
echo "============================================"
echo -e "${GREEN}Workspace $ISSUE_KEY is ready!${NC}"
echo "============================================"
echo ""
echo "Issue:     $ISSUE_URL"
echo "Title:     $TITLE"
echo "Profile:   $(get_profile_display_name "$SELECTED_PROFILE")"
if [[ -n "$PR_URL" ]]; then
    echo "PR:        $PR_URL"
fi
echo "Worktree:  $WORKTREE_PATH"
echo ""
if tmux has-session -t "$CLAUDE_SESSION_NAME" 2>/dev/null; then
    if [[ "$RESUME_MODE" == true ]]; then
        echo "Claude session ready (resume mode)."
    elif [[ -n "$INIT_CMD" ]]; then
        echo "Claude session ready with $INIT_CMD."
    else
        echo "Claude session ready: $CLAUDE_SESSION_NAME"
    fi
else
    echo "Warning: Claude session was not created."
fi
echo "Switch to workspace $ISSUE_KEY to start working."
echo ""

# Show notification
osascript -e "display notification \"Workspace ready: $TITLE\" with title \"$ISSUE_KEY\"" 2>/dev/null || true

log "=== $SCRIPT_NAME completed ==="
