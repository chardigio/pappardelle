#!/bin/bash

# dow - Do on Worktree
#
# A command-line tool that sets up a development workspace.
# Unlike idow (interactive), dow makes assumptions and proceeds without asking questions.
#
# Usage: dow <input>
#   Input can be:
#     - Issue key:   dow STA-123 | dow 123
#     - Linear URL:  dow https://linear.app/stardust-labs/issue/STA-123
#     - Description: dow "add dark mode to settings"
#
# This command:
#   1. Parses input (issue key, URL, or description)
#   2. Creates/fetches Linear issue as needed
#   3. Selects project profile from .pappardelle.yml
#   4. Creates a git worktree at ~/.worktrees/<project>/<issue-key>
#   5. Creates GitHub PR (if new)
#   6. Opens iTerm with Claude running /dow <description>
#   7. Opens Cursor, Xcode, Firefox, and QA simulator
#   8. Organizes windows in AeroSpace workspace

set -e

# Script identity (dow = non-interactive, idow = interactive)
SCRIPT_NAME="dow"

# Get the directory where this script lives (resolving symlinks)
SCRIPT_SOURCE="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_SOURCE" ]]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_SOURCE")" && pwd)"
    SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
    [[ "$SCRIPT_SOURCE" != /* ]] && SCRIPT_SOURCE="$SCRIPT_DIR/$SCRIPT_SOURCE"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_SOURCE")" && pwd)"

# Logging setup
LOG_DIR="$HOME/Library/Logs/stardust-workspace"
mkdir -p "$LOG_DIR"
LOG_FILE="$LOG_DIR/dow.log"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

error() {
    echo "Error: $*" >&2
    log "Error: $*"
    exit 1
}

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m'

TOTAL_STEPS=12
print_step() {
    echo -e "${BLUE}[$(printf '%2d' $1)/$TOTAL_STEPS]${NC} $2"
    log "Step $1: $2"
}

print_success() {
    echo -e "${GREEN}  ✓${NC} $1"
    log "  Success: $1"
}

print_warning() {
    echo -e "${YELLOW}  ⚠${NC} $1"
    log "  Warning: $1"
}

# Handle help flag
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    echo "Usage: dow [--resume] [--profile <name>] <input>"
    echo ""
    echo "Input can be:"
    echo "  Issue key:   dow STA-123 | dow 123"
    echo "  Linear URL:  dow https://linear.app/stardust-labs/issue/STA-123"
    echo "  Description: dow \"add dark mode to settings\""
    echo ""
    echo "Options:"
    echo "  --resume          Open workspace without prompting Claude (for continuing work)"
    echo "  --profile <name>  Force a specific profile from .pappardelle.yml"
    echo ""
    echo "Opens a workspace and runs Claude with /dow (non-interactive mode)."
    echo "Use 'idow' for interactive mode that asks clarifying questions."
    exit 0
fi

# Get repo root and config path
REPO_ROOT=$(cd "$SCRIPT_DIR" && git rev-parse --show-toplevel)
CONFIG_PATH="$REPO_ROOT/.pappardelle.yml"

# Check for config file
if [[ ! -f "$CONFIG_PATH" ]]; then
    echo -e "${YELLOW}Error: No .pappardelle.yml found at repository root.${NC}" >&2
    echo "" >&2
    echo "Pappardelle requires a configuration file to operate." >&2
    echo "Please create .pappardelle.yml at: $REPO_ROOT/.pappardelle.yml" >&2
    echo "" >&2
    echo "See _dev/scripts/pappardelle/pappardelle-config.md for the configuration schema." >&2
    exit 1
fi

# Check for yq (YAML processor)
if ! command -v yq &> /dev/null; then
    error "yq is required but not installed. Install with: brew install yq"
fi

# Read initialization command from config (e.g., "/idow", "/dow", or empty)
INIT_CMD=$(yq -r '.claude.initialization_command // ""' "$CONFIG_PATH")

# Source provider-agnostic helpers
# shellcheck source=provider-helpers.sh
source "$SCRIPT_DIR/provider-helpers.sh"

# Detect configured providers
TRACKER_PROVIDER=$(get_issue_tracker_provider "$CONFIG_PATH")
VCS_PROVIDER=$(get_vcs_host_provider "$CONFIG_PATH")

# Helper function to get profile value
get_profile_value() {
    local profile="$1"
    local path="$2"
    yq -r ".profiles.$profile.$path // empty" "$CONFIG_PATH"
}

# Helper function to list all profiles
list_profiles() {
    yq -r '.profiles | keys | .[]' "$CONFIG_PATH"
}

# Helper function to get profile display name
get_profile_display_name() {
    local profile="$1"
    yq -r ".profiles.$profile.display_name // \"$profile\"" "$CONFIG_PATH"
}

# Helper function to check if a profile has iOS config
profile_has_ios() {
    local profile="$1"
    local app_dir
    app_dir=$(get_profile_value "$profile" "ios.app_dir")
    [[ -n "$app_dir" ]]
}

# Function to match profiles based on keywords
match_profiles() {
    local input="$1"
    local input_lower
    input_lower=$(echo "$input" | tr '[:upper:]' '[:lower:]')

    local matched_profiles=()

    for profile in $(list_profiles); do
        local keywords
        keywords=$(yq -r ".profiles.$profile.keywords[]" "$CONFIG_PATH" 2>/dev/null)

        for keyword in $keywords; do
            local keyword_lower
            keyword_lower=$(echo "$keyword" | tr '[:upper:]' '[:lower:]')

            if [[ "$input_lower" == *"$keyword_lower"* ]]; then
                # Check if profile is already in matched list
                local already_matched=false
                for mp in "${matched_profiles[@]}"; do
                    if [[ "$mp" == "$profile" ]]; then
                        already_matched=true
                        break
                    fi
                done

                if [[ "$already_matched" == false ]]; then
                    matched_profiles+=("$profile")
                fi
                break
            fi
        done
    done

    echo "${matched_profiles[@]}"
}

# Check for --resume flag
RESUME_MODE=false
if [[ "$1" == "--resume" ]]; then
    RESUME_MODE=true
    shift
fi

# Check for --profile flag
FORCED_PROFILE=""
if [[ "$1" == "--profile" ]]; then
    FORCED_PROFILE="$2"
    shift 2

    # Validate the profile exists
    if ! list_profiles | grep -q "^${FORCED_PROFILE}$"; then
        echo -e "${YELLOW}Error: Profile \"$FORCED_PROFILE\" not found.${NC}" >&2
        echo "" >&2
        echo "Available profiles:" >&2
        for profile in $(list_profiles); do
            echo "  - $profile: $(get_profile_display_name "$profile")" >&2
        done
        exit 1
    fi
fi

# Collect input from all arguments
INPUT="$*"

if [[ -z "$INPUT" ]]; then
    echo "Usage: dow [--resume] [--profile <name>] <input>"
    echo ""
    echo "Input can be:"
    echo "  Issue key:   dow STA-123 | dow 123"
    echo "  Linear URL:  dow https://linear.app/stardust-labs/issue/STA-123"
    echo "  Description: dow \"add dark mode to settings\""
    exit 1
fi

log "=== $SCRIPT_NAME started ==="
log "Input: $INPUT"

echo ""
echo "Starting workspace setup..."
echo ""

# Determine input type and extract issue key if applicable
ISSUE_KEY=""
DESCRIPTION=""
IS_NEW_ISSUE=false

if [[ "$INPUT" =~ ^https://linear\.app/.*/issue/([A-Z]+-[0-9]+) ]]; then
    # Linear URL
    ISSUE_KEY="${BASH_REMATCH[1]}"
    log "Detected Linear URL, issue key: $ISSUE_KEY"
elif [[ "$INPUT" =~ ^[A-Z]+-[0-9]+$ ]]; then
    # Full issue key (e.g., STA-123)
    ISSUE_KEY="$INPUT"
    log "Detected full issue key: $ISSUE_KEY"
elif [[ "$INPUT" =~ ^[0-9]+$ ]]; then
    # Just a number (e.g., 123) - assume STA prefix
    ISSUE_KEY="STA-$INPUT"
    log "Detected number, assuming issue key: $ISSUE_KEY"
else
    # It's a description - we'll create a new issue
    DESCRIPTION="$INPUT"
    IS_NEW_ISSUE=true
    log "Detected description, will create new issue"
fi

# Step 1: Select profile from .pappardelle.yml
print_step 1 "Selecting project profile..."

SELECTED_PROFILE=""

if [[ -n "$FORCED_PROFILE" ]]; then
    # Profile was specified via --profile flag
    SELECTED_PROFILE="$FORCED_PROFILE"
    print_success "Using profile: $(get_profile_display_name "$SELECTED_PROFILE") (forced)"
elif [[ "$IS_NEW_ISSUE" == true ]]; then
    # Try to match profile based on description keywords
    MATCHED_PROFILES=$(match_profiles "$DESCRIPTION")
    MATCHED_COUNT=$(echo "$MATCHED_PROFILES" | wc -w | tr -d ' ')

    if [[ "$MATCHED_COUNT" -ge 1 ]]; then
        # Use first match (dow is non-interactive, so we just pick one)
        SELECTED_PROFILE=$(echo "$MATCHED_PROFILES" | awk '{print $1}')
        print_success "Auto-selected profile: $(get_profile_display_name "$SELECTED_PROFILE")"
    else
        # No matches - use default profile
        SELECTED_PROFILE=$(yq -r '.default_profile' "$CONFIG_PATH")
        print_success "Using default profile: $(get_profile_display_name "$SELECTED_PROFILE")"
    fi
else
    # Existing issue - use default profile
    SELECTED_PROFILE=$(yq -r '.default_profile' "$CONFIG_PATH")
    print_success "Using default profile: $(get_profile_display_name "$SELECTED_PROFILE")"
fi

# Extract profile values
IOS_APP_DIR=$(get_profile_value "$SELECTED_PROFILE" "ios.app_dir")
BUNDLE_ID=$(get_profile_value "$SELECTED_PROFILE" "ios.bundle_id")
SCHEME=$(get_profile_value "$SELECTED_PROFILE" "ios.scheme")
HAS_IOS=$(profile_has_ios "$SELECTED_PROFILE" && echo "true" || echo "false")

# Use profile name as project key
PROJECT_KEY="$SELECTED_PROFILE"

log "Profile: $SELECTED_PROFILE, iOS: $HAS_IOS, App Dir: $IOS_APP_DIR, Bundle: $BUNDLE_ID"

# Step 2: Get or create issue
print_step 2 "Setting up issue ($TRACKER_PROVIDER)..."

if [[ "$IS_NEW_ISSUE" == true ]]; then
    # Derive title
    print_step 3 "Generating issue title..."
    TITLE=$("$SCRIPT_DIR/derive-title.sh" "$DESCRIPTION") || error "Failed to derive title"
    print_success "Title: $TITLE"

    # Create issue via provider
    print_step 4 "Creating issue..."
    ISSUE_JSON=$(create_issue --title "$TITLE" --prompt "$DESCRIPTION" --config "$CONFIG_PATH") || error "Failed to create issue"
    ISSUE_KEY=$(echo "$ISSUE_JSON" | jq -r '.issue_key')
    ISSUE_URL=$(echo "$ISSUE_JSON" | jq -r '.issue_url')
    print_success "Created issue: $ISSUE_KEY (project will be assigned by Claude)"
else
    # Fetch existing issue via provider
    print_step 3 "Fetching issue ($TRACKER_PROVIDER)..."
    ISSUE_JSON=$(fetch_issue_json "$ISSUE_KEY" "$CONFIG_PATH") || error "Failed to fetch issue $ISSUE_KEY"
    TITLE=$(extract_issue_title "$ISSUE_JSON" "$CONFIG_PATH")
    DESCRIPTION=$(extract_issue_description "$ISSUE_JSON" "$CONFIG_PATH")
    ISSUE_URL=$(build_issue_url "$ISSUE_KEY" "$CONFIG_PATH")

    if [[ -z "$TITLE" ]]; then
        error "Issue $ISSUE_KEY not found"
    fi
    print_success "Issue: $TITLE"

    # Get project info from issue if available
    print_step 4 "Checking project..."
    LINEAR_PROJECT=$(echo "$ISSUE_JSON" | jq -r '.project.name // empty')
    if [[ -n "$LINEAR_PROJECT" ]]; then
        print_success "Project: $LINEAR_PROJECT"
    else
        print_success "No project assigned (will use defaults)"
    fi
fi

# Step 5: Create or find worktree
print_step 5 "Setting up git worktree..."
REPO_NAME=$(basename "$REPO_ROOT")
WORKTREE_PATH="$HOME/.worktrees/$REPO_NAME/$ISSUE_KEY"

if [[ -d "$WORKTREE_PATH" ]]; then
    print_success "Worktree exists: $WORKTREE_PATH"
else
    WORKTREE_JSON=$("$SCRIPT_DIR/create-worktree.sh" --issue-key "$ISSUE_KEY" --project-key "$PROJECT_KEY") || error "Failed to create worktree"
    WORKTREE_PATH=$(echo "$WORKTREE_JSON" | jq -r '.worktree_path')
    print_success "Created worktree: $WORKTREE_PATH"
fi

# Step 6: Check for existing PR/MR or create placeholder
print_step 6 "Setting up PR/MR ($VCS_PROVIDER)..."
cd "$WORKTREE_PATH"
PR_URL=$(check_existing_pr "$CONFIG_PATH")
if [[ -n "$PR_URL" ]]; then
    print_success "Found PR/MR: $PR_URL"
else
    # Create placeholder PR/MR so links work immediately
    PR_JSON=$(create_pr \
        --issue-key "$ISSUE_KEY" \
        --title "$TITLE" \
        --worktree "$WORKTREE_PATH" \
        --config "$CONFIG_PATH" \
        --prompt "$DESCRIPTION") || {
        print_warning "Failed to create placeholder PR/MR"
        PR_URL=""
    }
    if [[ -n "$PR_JSON" ]]; then
        PR_URL=$(echo "$PR_JSON" | jq -r '.pr_url // empty')
        if [[ -n "$PR_URL" ]]; then
            print_success "Created placeholder PR/MR: $PR_URL"
        fi
    fi
fi

# Step 7: Generate Xcode project (if iOS profile)
XCODEPROJ_PATH=""
if [[ "$HAS_IOS" == "true" && -n "$IOS_APP_DIR" ]]; then
    print_step 7 "Generating Xcode project..."
    XCODE_JSON=$("$SCRIPT_DIR/generate-xcode-project.sh" --worktree "$WORKTREE_PATH" --issue-key "$ISSUE_KEY" --ios-app-dir "$IOS_APP_DIR") || {
        print_warning "Failed to generate Xcode project"
        XCODE_JSON="{}"
    }
    XCODEPROJ_PATH=$(echo "$XCODE_JSON" | jq -r '.xcodeproj_path // empty')
    if [[ -n "$XCODEPROJ_PATH" ]]; then
        print_success "Xcode project: $(basename "$XCODEPROJ_PATH")"
    fi
else
    print_step 7 "Skipping Xcode project (no iOS config)..."
    print_success "Profile has no iOS configuration"
fi

# Step 8: Open iTerm with Claude and lazygit
print_step 8 "Opening iTerm with Claude..."
# In resume mode, start Claude without any prompt; otherwise use configured init command
if [[ "$RESUME_MODE" == true ]]; then
    CLAUDE_PROMPT=""
    "$SCRIPT_DIR/open-iterm-claude.sh" --worktree "$WORKTREE_PATH" --issue-key "$ISSUE_KEY" --prompt "" || {
        print_warning "Failed to open iTerm"
    }
    print_success "iTerm opened with Claude (resume mode)"
elif [[ -n "$INIT_CMD" ]]; then
    CLAUDE_PROMPT="$INIT_CMD $ISSUE_KEY"
    "$SCRIPT_DIR/open-iterm-claude.sh" --worktree "$WORKTREE_PATH" --issue-key "$ISSUE_KEY" --prompt "$CLAUDE_PROMPT" || {
        print_warning "Failed to open iTerm"
    }
    print_success "iTerm opened with Claude session ($INIT_CMD)"
else
    CLAUDE_PROMPT=""
    "$SCRIPT_DIR/open-iterm-claude.sh" --worktree "$WORKTREE_PATH" --issue-key "$ISSUE_KEY" --prompt "" || {
        print_warning "Failed to open iTerm"
    }
    print_success "iTerm opened with Claude (no initialization command configured)"
fi

# Step 9: Open Cursor
print_step 9 "Opening Cursor..."
"$SCRIPT_DIR/open-cursor.sh" --worktree "$WORKTREE_PATH" --issue-key "$ISSUE_KEY" || {
    print_warning "Failed to open Cursor"
}
print_success "Cursor opened"

# Step 10: Open Xcode (if iOS profile)
if [[ "$HAS_IOS" == "true" && -n "$XCODEPROJ_PATH" && -d "$XCODEPROJ_PATH" ]]; then
    print_step 10 "Opening Xcode..."
    open "$XCODEPROJ_PATH"
    # Position Xcode immediately (position 8 = middle column, full height)
    "$SCRIPT_DIR/position-window.sh" \
        --app "Xcode" \
        --title "$ISSUE_KEY" \
        --workspace "$ISSUE_KEY" \
        --position 8 &
    print_success "Xcode opened"
else
    print_step 10 "Skipping Xcode (no project)..."
    print_success "No Xcode project to open"
fi

# Step 11: Setup QA simulator (if iOS profile)
SIM_PID=""
if [[ "$HAS_IOS" == "true" && -n "$IOS_APP_DIR" && -n "$BUNDLE_ID" ]]; then
    print_step 11 "Setting up QA simulator..."
    "$SCRIPT_DIR/setup-qa-simulator.sh" --worktree "$WORKTREE_PATH" --issue-key "$ISSUE_KEY" --ios-app-dir "$IOS_APP_DIR" --bundle-id "$BUNDLE_ID" &
    SIM_PID=$!
    print_success "Simulator setup started (building in background)"
else
    print_step 11 "Skipping QA simulator (no iOS config)..."
    print_success "Profile has no iOS configuration"
fi

# Step 12: Open Firefox with issue and PR tabs
print_step 12 "Opening Firefox..."
"$SCRIPT_DIR/open-firefox-tabs.sh" --issue-key "$ISSUE_KEY" --issue-url "$ISSUE_URL" --pr-url "$PR_URL" || {
    print_warning "Failed to open Firefox"
}
print_success "Firefox opened"

# Run post_workspace_create hooks (if configured)
HOOK_COUNT=$(yq -r '.hooks.post_workspace_create | length // 0' "$CONFIG_PATH" 2>/dev/null)
if [[ "$HOOK_COUNT" -gt 0 ]]; then
    log "Running $HOOK_COUNT post_workspace_create hook(s)..."
    for (( i=0; i<HOOK_COUNT; i++ )); do
        HOOK_NAME=$(yq -r ".hooks.post_workspace_create[$i].name // \"hook $i\"" "$CONFIG_PATH")
        HOOK_RUN=$(yq -r ".hooks.post_workspace_create[$i].run // \"\"" "$CONFIG_PATH")
        HOOK_CONTINUE=$(yq -r ".hooks.post_workspace_create[$i].continue_on_error // false" "$CONFIG_PATH")
        HOOK_BG=$(yq -r ".hooks.post_workspace_create[$i].background // false" "$CONFIG_PATH")

        # Expand template variables in the command
        HOOK_RUN="${HOOK_RUN//\$\{SCRIPT_DIR\}/$SCRIPT_DIR}"
        HOOK_RUN="${HOOK_RUN//\$\{WORKTREE_PATH\}/$WORKTREE_PATH}"
        HOOK_RUN="${HOOK_RUN//\$\{ISSUE_KEY\}/$ISSUE_KEY}"
        HOOK_RUN="${HOOK_RUN//\$\{REPO_ROOT\}/$REPO_ROOT}"
        HOOK_RUN="${HOOK_RUN//\$\{REPO_NAME\}/$REPO_NAME}"
        HOOK_RUN="${HOOK_RUN//\$\{PR_URL\}/$PR_URL}"
        HOOK_RUN="${HOOK_RUN//\$\{IOS_APP_DIR\}/$IOS_APP_DIR}"
        HOOK_RUN="${HOOK_RUN//\$\{BUNDLE_ID\}/$BUNDLE_ID}"

        if [[ -n "$HOOK_RUN" ]]; then
            log "  Hook: $HOOK_NAME -> $HOOK_RUN"
            if [[ "$HOOK_BG" == "true" ]]; then
                eval "$HOOK_RUN" &
            elif [[ "$HOOK_CONTINUE" == "true" ]]; then
                eval "$HOOK_RUN" || print_warning "Hook '$HOOK_NAME' failed (continuing)"
            else
                eval "$HOOK_RUN" || { print_warning "Hook '$HOOK_NAME' failed"; exit 1; }
            fi
        fi
    done
fi

# Wait for simulator if started
if [[ -n "$SIM_PID" ]]; then
    echo ""
    echo "Waiting for simulator..."
    if wait "$SIM_PID" 2>/dev/null; then
        print_success "Simulator ready"
    else
        print_warning "Simulator setup may have failed"
    fi
fi

# Switch to the workspace
aerospace workspace "$ISSUE_KEY" 2>/dev/null || true

# Final summary
echo ""
echo "============================================"
echo -e "${GREEN}Workspace $ISSUE_KEY is ready!${NC}"
echo "============================================"
echo ""
echo "Issue:     $ISSUE_URL"
echo "Title:     $TITLE"
echo "Profile:   $(get_profile_display_name "$SELECTED_PROFILE")"
if [[ -n "$PR_URL" ]]; then
    echo "PR:        $PR_URL"
fi
echo "Worktree:  $WORKTREE_PATH"
echo ""
if [[ -n "$INIT_CMD" ]]; then
    echo "Claude is running with $INIT_CMD (non-interactive mode)."
else
    echo "Claude is running (no initialization command configured)."
fi
echo "Switch to workspace $ISSUE_KEY to start working."
echo ""

# Show notification
osascript -e "display notification \"Workspace ready: $TITLE\" with title \"$ISSUE_KEY\"" 2>/dev/null || true

log "=== $SCRIPT_NAME completed ==="
